C51 COMPILER V9.01   STOPWATCH                                                             01/14/2019 21:50:30 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE STOPWATCH
OBJECT MODULE PLACED IN stopwatch.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE src\stopwatch.c COMPACT BROWSE PRINT(.\stopwatch.lst) OBJECT(stopwatch.obj)

line level    source

   1          #include "../h/port.h"
   2          #include "../h/utility.h"
   3          #include "string.h"
   4          #include "../h/82c55.h"
   5          #include "../h/serial.h"
   6          
   7          #include "../h/scroll.h"
   8          #include "../h/led.h" 
   9          #include "../h/stopwatch.h"
  10          #include "../h/alarm.h"
  11          #include "../h/ds1302.h"
  12          #include "../h/eeprom.h"
  13          #include "../h/systimer.h"
  14          #include "../h/keyprocess.h"
  15          #include "../h/voltage.h"
  16          //volatile bit g_1ms_triggered = 0;
  17          static   bit g_paused = 0;       
  18           
  19          //7 seg led refresh timer---------------------
  20          uchar g_refresh_battery_icon_start = e_timer_stop; 
  21          #define BATTERY_ICON_FLASH 50      //0.5s flash ， 10ms for one tick
  22          //--------------------------------------------
  23          uchar g_saved_count_time   = 0;
  24          char  g_timer_to_count_min = 0;
  25          char  g_timer_to_count_sec = 0;
  26          //some system used timer---------------------------------------------------------------
  27          #ifdef TEST
              uchar volatile g_1s_test_timer       = e_timer_stop;
              #endif
  30          uchar volatile g_100ms_timer         = e_timer_stop;      //used for scroll 
  31          uchar volatile g_alarm_timeout_timer = e_timer_stop;      //used for alarm timer out time
  32          uchar volatile g_1s_key_timer        = e_timer_stop;      //used for key press time
  33          
  34          uchar volatile g_1min_sys_idle_timer = e_timer_stop;
  35          uchar volatile g_sys_idle_time_1min  = 0; 
  36          
  37          uchar volatile g_1min_poll_battery_timer   =  e_timer_finished;// used for poll battery voltage
  38          unsigned int g_poll_voltage_timer_interval = 0;
  39          
  40          
  41          //-------------------------------------------------------------------------------------
  42          
  43          //ds1302 poll timer-------------------------------------------s
  44          uchar volatile g_poll_ds1302_timer_start  = e_timer_stop;
  45          unsigned int volatile g_poll_ds1302_timer = 0;
  46          //------------------------------------------------------------
  47          
  48          //alarm led blink timer---------------------------------------
  49          char g_blink_function_start      = e_timer_stop;
  50          unsigned int g_blink_led_counter = 0;
  51          bit g_blink_off_flag             = 0;
  52          #define BLINK_OFF_MS 20  //200ms
  53          #define BLINK_ON_MS  30  //300ms
  54          //------------------------------------------------------------
  55          
C51 COMPILER V9.01   STOPWATCH                                                             01/14/2019 21:50:30 PAGE 2   

  56          #define check_timer(g_poll_start, old_poll_ticket, COUNT_TICKET)       \
  57          {                                                                      \
  58              if(e_timer_start == g_poll_start)                                  \
  59              {                                                                  \
  60                  old_poll_ticket = g_sys_10ms_ticket;                           \
  61                  g_poll_start    = e_timer_counting;                            \
  62              }                                                                  \                       
  63              else if(e_timer_counting == g_poll_start)                          \
  64              {                                                                  \
  65                  if(old_poll_ticket < g_sys_10ms_ticket)                        \
  66                  {                                                              \
  67                      temp = g_sys_10ms_ticket - old_poll_ticket;                \
  68                  }                                                              \
  69                  else                                                           \
  70                  {                                                              \ 
  71                      temp = 0xffff - old_poll_ticket + 1 + g_sys_10ms_ticket;   \
  72                  }                                                              \
  73                  if(temp >= COUNT_TICKET) g_poll_start = e_timer_finished;      \
  74              }                                                                  \
  75          }                                                                    
  76                                                        
  77          void calc_time()
  78          {
  79   1          unsigned int temp =0;
  80   1          static unsigned int old_5s_timer_ticket     = 0;
  81   1          static unsigned int old_100ms_timer_ticket  = 0;
  82   1          static unsigned int old_poll_ds1302_ticket  = 0;
  83   1          static unsigned int old_blink_ticket        = 0;
  84   1          static unsigned int olg_battery_icon_flash_ticket = 0;
  85   1          static unsigned int old_key_pressing_ticket = 0;
  86   1          static unsigned int old_1min_timeout_ticket = 0;
  87   1          static unsigned int old_poll_battery_timer_ticket = 0;
  88   1      
  89   1          #ifdef TEST 
                  static unsigned int old_1s_testtimer_ticket  = 0;
                  check_timer(g_1s_test_timer, old_1s_testtimer_ticket, 100);
                  #endif
  93   1      
  94   1          //100ms timer check        //100ms timer check//100ms timer check
  95   1          check_timer(g_100ms_timer, old_100ms_timer_ticket, 10)
  96   1          check_timer(g_1min_sys_idle_timer, old_1min_timeout_ticket, 6000);   
  97   1          check_timer(g_1min_poll_battery_timer, old_poll_battery_timer_ticket,100);//6000);                    
             -          
  98   1          check_timer(g_1s_key_timer, old_key_pressing_ticket, 100);
  99   1          //5s timer check  
 100   1          check_timer(g_alarm_timeout_timer, old_5s_timer_ticket, 600);//6s
 101   1       
 102   1          //ds1302s check          //used for poll ds1302 sec; //first timer ==960, then 10ms one time until 1s 
             -trigger from ds1302
 103   1          check_timer(g_poll_ds1302_timer_start, old_poll_ds1302_ticket, g_poll_ds1302_timer);//g_poll_ds1302_ti
             -mer);
 104   1       
 105   1          //flash battery timer
 106   1          check_timer(g_refresh_battery_icon_start, olg_battery_icon_flash_ticket, BATTERY_ICON_FLASH);
 107   1      
 108   1          // for blink led
 109   1          check_timer(g_blink_function_start, old_blink_ticket, g_blink_led_counter);
 110   1          if(e_timer_finished == g_blink_function_start)
 111   1          {
 112   2              g_blink_off_flag = !g_blink_off_flag;    //g_blink_flag ==1 led off ,
 113   2              if(g_blink_off_flag)
 114   2              {
C51 COMPILER V9.01   STOPWATCH                                                             01/14/2019 21:50:30 PAGE 3   

 115   3                  g_blink_led_counter = BLINK_OFF_MS;
 116   3                  black_display();
 117   3                  stop_alarm();
 118   3              }
 119   2              else
 120   2              {    
 121   3                  start_alarm();
 122   3                  g_blink_led_counter = BLINK_ON_MS;
 123   3                  update_min(g_timer_to_count_min);
 124   3                  update_sec(g_timer_to_count_sec);
 125   3              }
 126   2              g_blink_function_start  = e_timer_start;
 127   2         }
 128   1      }
 129           
 130          
 131          char  volatile g_sys_state = e_idle;
 132          sbit g_key_state = P1^0;
 133          void init_hardware(void)
 134          {
 135   1          //init_low_power_inter();// low voltage detect...
 136   1              #ifdef KEY_INTERRUPT_
                      init_key();
                      #endif
 139   1              enable_voltage_read_init();
 140   1          serial_port_init        ();  
 141   1          init_timer ();
 142   1          ds1302_init();
 143   1          ds1302_stop();
 144   1          init_display ();
 145   1          black_display();
 146   1      }
 147          
 148          #define init_timer_and_state()                    \
 149          {   g_sys_state = e_idle;  stop_alarm();          \
 150              init_scroll();                                \
 151              g_1min_sys_idle_timer = e_timer_stop;         \
 152              g_sys_idle_time_1min  = 0;                    \
 153              g_blink_function_start = e_timer_stop;        \
 154              g_blink_off_flag = 0;                         \
 155              g_poll_ds1302_timer_start = e_timer_stop;     \
 156              g_100ms_timer  = e_timer_stop;                \
 157              g_1s_key_timer = e_timer_stop;                \
 158              g_alarm_timeout_timer    = e_timer_stop;      \
 159              g_timer_to_count_min = 0;                     \
 160              g_timer_to_count_sec = 0;                     \
 161              g_key_released = 0; g_key_pressed = 0;        \ 
 162              g_key_pressing_1s = 0; g_paused = 0;          \
 163              g_poll_voltage_timer_interval = 10;            \
 164              g_1min_poll_battery_timer = e_timer_finished; \
 165                  g_refresh_battery_icon_start = e_timer_stop; g_battery = g_battery_display = 0; \
 166          }
 167          
 168          bit g_wakeup_from_sleep_flag = 0;
 169           
 170          uchar g_battery = 0;
 171          uchar g_battery_display = 0;
 172          void poll_voltage()                                                 
 173          {   
 174   1          if(g_battery == 0)                                              
 175   1          {                                                               
 176   2              if(g_refresh_battery_icon_start == e_timer_stop)            
C51 COMPILER V9.01   STOPWATCH                                                             01/14/2019 21:50:30 PAGE 4   

 177   2              {                                                           
 178   3                  g_refresh_battery_icon_start = e_timer_start;           
 179   3              }                                                           
 180   2              else if( e_timer_finished == g_refresh_battery_icon_start)  
 181   2              {                                                           
 182   3                  g_battery_display = !g_battery_display;      
 183   3                  update_sec(g_timer_to_count_sec);                                           
 184   3                  update_min(g_timer_to_count_min);                   
 185   3                  g_refresh_battery_icon_start = e_timer_start;           
 186   3              }                                                           
 187   2          }                                                                
 188   1          if(e_timer_finished == g_1min_poll_battery_timer)               
 189   1          {                                                               
 190   2              g_poll_voltage_timer_interval++;                            
 191   2              g_1min_poll_battery_timer= e_timer_start;                   
 192   2          }                                                               
 193   1          else if(e_timer_stop == g_1min_poll_battery_timer)              
 194   1          {                                                               
 195   2              g_1min_poll_battery_timer = e_timer_start;                  
 196   2          }      
 197   1                                                                       
 198   1          if(g_poll_voltage_timer_interval <10) return;                    
 199   1          g_battery = get_voltage();                                  
 200   1          if(-1 == g_battery){ return; }                                  
 201   1          g_poll_voltage_timer_interval = 0;                              
 202   1              send_buffer("vol");send_integ(g_battery);
 203   1                                                                     
 204   1          if(g_battery > 0)                                          
 205   1          {                                                               
 206   2              if(g_battery_display!= g_battery)                                                       
 207   2                      {
 208   3                              g_battery_display = g_battery;                             
 209   3                  update_sec(g_timer_to_count_sec);                                           
 210   3                  update_min(g_timer_to_count_min);
 211   3                      }                                       
 212   2          }                                                               
 213   1      }                                                                       
 214          
 215          void main()
 216          {
 217   1          char scroll_count = 0;
 218   1              close_rgb_led();
 219   1      INIT_START:
 220   1          //P0M0 = 0;
 221   1          //P0M1 = 0;
 222   1          close_rgb_led();
 223   1          init_timer_and_state();
 224   1          init_hardware();
 225   1      
 226   1          g_saved_count_time = IapRead(0x400);
 227   1      
 228   1          if(g_saved_count_time > 99) g_saved_count_time = 0;
 229   1          g_timer_to_count_min = g_saved_count_time;
 230   1          send_buffer("saved time:"); send_integ(g_saved_count_time);
 231   1          update_sec(g_timer_to_count_sec);
 232   1          update_min(g_timer_to_count_min);
 233   1          g_refresh_battery_icon_start = e_timer_start; 
 234   1          #ifdef TEST
                  g_1s_test_timer = e_timer_start;     ds1302_start();      // test only 
                  #endif
 237   1          while(1)
 238   1          {   
C51 COMPILER V9.01   STOPWATCH                                                             01/14/2019 21:50:30 PAGE 5   

 239   2              calc_time();
 240   2                      
 241   2              #ifdef TEST
                          if(e_timer_finished == g_1s_test_timer){ ds1302_read_sec(); g_1s_test_timer = e_timer_start;} 
             -    //test only
                      #endif
 244   2              {       
 245   3                  scan_roll(e_roll_a);         process_key();  
 246   3                  get_key_state();
 247   3                  {
 248   4                      scroll_count = 0;
 249   4                      if(g_plus_count[e_roll_a] && e_timer_stop == g_100ms_timer)
 250   4                      {
 251   5                          g_100ms_timer = e_timer_start;         //trigger 100ms timer
 252   5                      }
 253   4                      if(e_timer_finished == g_100ms_timer)       //1 means 100ms count up 
 254   4                      {     
 255   5                          g_100ms_timer = e_timer_stop;
 256   5                          scroll_count  = g_plus_count[e_roll_a];
 257   5                          g_plus_count[e_roll_a] = 0;
 258   5                      }
 259   4                  } 
 260   3              }              
 261   2              if(0 == g_key_pressing_1s && 0 == g_key_released && 0 == g_key_pressed && e_idle == g_sys_state &&
             - 0 == g_plus_count[e_roll_a] && 0 == scroll_count)//没有案件按下,也没有按键释放. 开始计时.5分钟
 262   2              {
 263   3                  if(e_timer_finished == g_1min_sys_idle_timer)
 264   3                  {
 265   4                      g_sys_idle_time_1min++; 
 266   4                      g_1min_sys_idle_timer= e_timer_start;
 267   4                  }
 268   3                  else if(e_timer_stop == g_1min_sys_idle_timer)
 269   3                  {
 270   4                      g_1min_sys_idle_timer = e_timer_start;
 271   4                  }
 272   3              }
 273   2              else
 274   2              {    
 275   3                  g_sys_idle_time_1min = 0;
 276   3                  g_1min_sys_idle_timer = e_timer_stop;
 277   3              }                                        
 278   2            
 279   2              if(e_idle == g_sys_state)poll_voltage();
 280   2      
 281   2              if(g_key_pressing_1s >= 3 || g_sys_idle_time_1min >= 1)
 282   2              {     
 283   3                 
 284   3                  if(IapRead(0x400) != g_saved_count_time) 
 285   3                  {
 286   4                      IapWrite(0x400, g_saved_count_time);
 287   4                  }
 288   3                  VOCTRL = 0;            // 选择内部静态保持电流控制线路,静态电流 1.5uA
 289   3                  // VOCTRL = 0x80;           // 选择外部静态保持电流控制线路,电流小于 0.1uA
 290   3                  P_SW2 = 0; //IT2 = 0;    //下降沿中断 
 291   3                  IE2 = ES2;  //EX0 = 1;   //使能中断 
 292   3                  black_display();
 293   3                  close_display();
 294   3                  close_rgb_led();
 295   3                  disable_voltage_read();
 296   3                                        stop_sys_timer();
 297   3                                   stop_scroll();
 298   3                                   ds1302_shutdown();
C51 COMPILER V9.01   STOPWATCH                                                             01/14/2019 21:50:30 PAGE 6   

 299   3                                                stop_alarm();
 300   3                  //pcon |=0x1; //MCU idle
 301   3                  while(0 == g_key_state)Delay(799);
 302   3                  send_buffer("goto sleep, keypressing"); send_integ(g_key_state);
 303   3                  PCON = 0x02; //MCU sleep
 304   3                  g_wakeup_from_sleep_flag=1; 
 305   3                          while(0 == g_key_state)Delay(799);
 306   3                  goto INIT_START;
 307   3              }//g_sys_state=      e_test ;
 308   2              switch(g_sys_state)
 309   2              {
 310   3                  case e_idle:  
 311   3                      if     (scroll_count> 10){scroll_count += 12;}
 312   3                      else if(scroll_count<-10){scroll_count -= 12;}                     
 313   3                      else if(scroll_count> 9 ){scroll_count += 10;}
 314   3                      else if(scroll_count<-9 ){scroll_count -= 10;}
 315   3                      else if(scroll_count> 6 ){scroll_count += 4 ;}
 316   3                      else if(scroll_count<-6 ){scroll_count -= 4 ;}
 317   3                      g_timer_to_count_min += scroll_count;
 318   3                      if(scroll_count!=0)
 319   3                      {
 320   4      
 321   4                          if(g_timer_to_count_min > 99) g_timer_to_count_min -= 100;
 322   4                          if(g_timer_to_count_min < 0) g_timer_to_count_min = 100 + g_timer_to_count_min;
 323   4                          if(g_saved_count_time != g_timer_to_count_min)
 324   4                          {
 325   5                              send_integ(g_timer_to_count_min); 
 326   5                              g_saved_count_time = g_timer_to_count_min;
 327   5                          }
 328   4                          update_min(g_timer_to_count_min);
 329   4                      }
 330   3                      if(g_key_pressed)
 331   3                      { 
 332   4                          ds1302_start();        
 333   4                          //send_buffer("rxn!");   
 334   4                          if(IapRead(0x400) != g_saved_count_time)
 335   4                          {
 336   5                              IapWrite(0x400, g_timer_to_count_min); g_saved_count_time = g_timer_to_count_min;
 337   5                          }
 338   4                          g_100ms_timer = e_timer_stop;// cancel poll scroll
 339   4                          //if(g_timer_to_count_min>99) g_timer_to_count_min -= 99;
 340   4                          //if(g_timer_to_count_min<0) g_timer_to_count_min = 100 +    g_timer_to_count_min;
 341   4                          
 342   4                          g_sys_state = e_count_down;
 343   4                          if(0 == g_timer_to_count_min)   
 344   4                          {            
 345   5                              //g_poll_ds1302_timer = 900;//begin to poll ds1302 for 1s
 346   5                              g_sys_state = e_count_up;
 347   5                          }
 348   4       
 349   4                          //send_int(g_timer_to_count_min);//debug use  
 350   4                          g_poll_ds1302_timer = 98;   //begin to poll ds1302 for 1s
 351   4                          g_poll_ds1302_timer_start = e_timer_start;
 352   4                          start_breath_blink();// info user counter is running
 353   4                      }
 354   3                  break;
 355   3                  case e_count_up:
 356   3                      if(e_timer_finished == g_poll_ds1302_timer_start)
 357   3                      {
 358   4                          if( ds1302_1s_trigger())
 359   4                          {
 360   5                              g_poll_ds1302_timer_start = e_timer_start;
C51 COMPILER V9.01   STOPWATCH                                                             01/14/2019 21:50:30 PAGE 7   

 361   5                              g_poll_ds1302_timer = 99; 
 362   5                              if(1 == g_paused)
 363   5                              break;
 364   5                              g_timer_to_count_sec++;
 365   5                              if(g_timer_to_count_sec == 60)
 366   5                              {
 367   6                                  g_timer_to_count_min++;
 368   6                                  g_timer_to_count_sec = 0;  
 369   6                                  if(g_timer_to_count_min ==  100)
 370   6                                      g_timer_to_count_min = 0; 
 371   6                                  update_min(g_timer_to_count_min);
 372   6                              }
 373   5                              update_sec(g_timer_to_count_sec);
 374   5                              {
 375   6                                  send_integ(g_timer_to_count_min);    //debug use
 376   6                                  send_integ(g_timer_to_count_sec);    //debug use
 377   6                              }
 378   5                          }
 379   4                          else
 380   4                          {
 381   5                              g_poll_ds1302_timer_start = e_timer_start;
 382   5                              g_poll_ds1302_timer = 1; 
 383   5                          }
 384   4      
 385   4                      }
 386   3                      if(g_key_pressed)//pause
 387   3                      {
 388   4                          g_paused = !g_paused;
 389   4                          //if(!g_paused)start_breath_blink();// info user counter is runnin
 390   4                          //else close_rgb_led();
 391   4                      } 
 392   3                      if(scroll_count >=5 || scroll_count<=-5)
 393   3                      {
 394   4                          g_poll_ds1302_timer_start = e_timer_stop;
 395   4                          g_sys_state = e_temp;
 396   4                          ds1302_stop();close_rgb_led();
 397   4                          g_timer_to_count_min = 0;
 398   4                          g_timer_to_count_sec = 0;  update_min(g_timer_to_count_min); update_sec(g_timer_to_cou
             -nt_sec);
 399   4                      }
 400   3                  break;
 401   3                  case e_count_down:
 402   3                  {         
 403   4                      if(g_poll_ds1302_timer_start == e_timer_finished)
 404   4                      {        
 405   5                          if(ds1302_1s_trigger())
 406   5                          {
 407   6                               g_poll_ds1302_timer_start = e_timer_start;
 408   6                               g_poll_ds1302_timer = 99; 
 409   6                               if(1 == g_paused)
 410   6                               break;
 411   6                               if(g_timer_to_count_sec)
 412   6                               {
 413   7                                   g_timer_to_count_sec --;
 414   7                                   
 415   7                               }
 416   6                               else                              
 417   6                               {
 418   7                                   g_timer_to_count_sec = 59;
 419   7                                   g_timer_to_count_min --;
 420   7                                   update_min(g_timer_to_count_min);
 421   7                               }
C51 COMPILER V9.01   STOPWATCH                                                             01/14/2019 21:50:30 PAGE 8   

 422   6                               update_sec(g_timer_to_count_sec);
 423   6                               {
 424   7                                  send_integ(g_timer_to_count_min);    //debug use
 425   7                                  send_integ(g_timer_to_count_sec);    //debug use
 426   7                               }
 427   6                               if((g_timer_to_count_sec+g_timer_to_count_min) == 0)
 428   6                               {
 429   7                                  g_poll_ds1302_timer = e_stop; ds1302_stop();
 430   7                                  g_sys_state = e_finished_alarm;
 431   7                                  //set_HZ(17.23);
 432   7                                  set_HZ(5000);
 433   7                                  set_duty(50);
 434   7                                  //start_alarm();
 435   7                                  start_alarm_blink();
 436   7                                  g_alarm_timeout_timer = e_timer_start; 
 437   7                                   
 438   7                                  g_blink_led_counter =  BLINK_OFF_MS;
 439   7                                  g_blink_off_flag = 1; 
 440   7                                  g_blink_function_start = e_timer_start;
 441   7                              }    
 442   6                          }
 443   5                          else
 444   5                          {
 445   6                              g_poll_ds1302_timer_start = e_timer_start;
 446   6                              g_poll_ds1302_timer = 1;       //every 5ms goto check wether the 1s timer is trigg
             -ered
 447   6                              break;
 448   6                          }
 449   5                      }    
 450   4                      if(g_key_pressed)//pause
 451   4                      {
 452   5                          g_paused = !g_paused;
 453   5                          //if(!g_paused)start_breath_blink();// info user counter is runnin
 454   5                          //else close_rgb_led();
 455   5                      }  
 456   4                      if(scroll_count >= 5 || scroll_count <= -5)
 457   4                      {       
 458   5                                      close_rgb_led();
 459   5                          g_poll_ds1302_timer_start = e_timer_stop;
 460   5                          g_timer_to_count_min = g_saved_count_time;
 461   5                          g_timer_to_count_sec = 0;
 462   5                          g_sys_state = e_temp;     update_min(g_timer_to_count_min); update_sec(g_timer_to_coun
             -t_sec);
 463   5                      }      
 464   4                  }
 465   3                  break;
 466   3                  case e_finished_alarm:
 467   3                  {  
 468   4                      //set_HZ(16.39);
 469   4                      if(g_alarm_timeout_timer == e_timer_finished ||g_key_released||scroll_count||g_plus_count[
             -e_roll_a])
 470   4                      {
 471   5                          stop_alarm();close_rgb_led();
 472   5                          g_blink_function_start = e_timer_stop; g_blink_off_flag = 0;
 473   5                          g_alarm_timeout_timer = e_timer_stop;
 474   5                          send_buffer("goto idle");
 475   5                          g_timer_to_count_min = g_saved_count_time;
 476   5                          g_timer_to_count_sec = 0;
 477   5                          g_sys_state = e_idle;
 478   5                          g_plus_count[e_roll_a] = 0;
 479   5                          update_min(g_timer_to_count_min); update_sec(g_timer_to_count_sec);
 480   5                      }
C51 COMPILER V9.01   STOPWATCH                                                             01/14/2019 21:50:30 PAGE 9   

 481   4                   }
 482   3                  break;
 483   3                  case e_temp:
 484   3                  if(0 == scroll_count)
 485   3                  g_sys_state = e_idle;
 486   3                  break;
 487   3                  #if 0
                          case e_test:
                          {
                          static bit stat = 0;
                          static int hz = 17.23;
                          if(stat ==0 && g_key_pressed)
                          {
                              //set_HZ(17.23);
                              stat =1;
                              set_HZ(hz);
                              //set_duty(1000);
                              start_alarm();
                              update_min(hz/100);
                              update_sec(hz%100);
                          }
                          else if(1 == stat && g_key_pressed)
                          {
                              stop_alarm();close_rgb_led();
                          }
                          if(1 == stat)
                          {
                              update_blink_flash_led();
                          }
                          if(scroll_count)
                          {
                              if     (scroll_count> 10){scroll_count += 12;}
                              else if(scroll_count<-10){scroll_count -= 12;}                     
                              else if(scroll_count> 9 ){scroll_count += 10;}
                              else if(scroll_count<-9 ){scroll_count -= 10;}
                              else if(scroll_count> 6 ){scroll_count += 4 ;}
                              else if(scroll_count<-6 ){scroll_count -= 4 ;}
                              hz+=scroll_count*100;
                              update_min(hz/100);
                              update_sec(hz%100);
                              set_HZ(hz);
                          }
                          
                           }
                          break;
                          #endif
 527   3              }
 528   2              scroll_count = 0;
 529   2            }
 530   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2203    ----
   CONSTANT SIZE    =     50    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     37       1
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
