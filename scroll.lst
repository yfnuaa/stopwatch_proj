C51 COMPILER V9.01   SCROLL                                                                01/14/2019 21:22:32 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE SCROLL
OBJECT MODULE PLACED IN scroll.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE src\scroll.c COMPACT BROWSE PRINT(.\scroll.lst) OBJECT(scroll.obj)

line level    source

   1          #include "../h/port.h"
   2          #include "../h/scroll.h"
   3          #include "../h/utility.h"
   4          #include "../h/serial.h"
   5          
   6          sbit PLUS_0_A_IN = P1^1;
   7          sbit PLUS_0_B_IN = P1^2;
   8          char g_plus_status  [e_roll_max] = {e_stop};
   9          char g_plus_sub_status  [e_roll_max] = {e_stop};
  10          
  11          char g_plus_a_in    [e_roll_max] = {high};
  12          char g_plus_a_in_old[e_roll_max] = {high};
  13          char g_plus_b_in    [e_roll_max] = {high};
  14          char g_plus_b_in_old[e_roll_max] = {high};
  15          char g_plus_count[ e_roll_max] = {0};    
  16          #if 1                                                                            
  17          uchar g_juggle_delay = 0;
  18          #define A_IN_hight_input   P1M1 |= 0x02; P1M0 &= ~0x02;//P16  //P2M1 |= 0x80; P2M0 &= ~0x80; //P27 //1 0 ¸
             -ß×èÊäÈë
  19          #define B_IN_hight_input   P1M1 |= 0x04; P1M0 &= ~0x04;//P16  //P2M1 |= 0x80; P2M0 &= ~0x80; //P27 //1 0 ¸
             -ß×èÊäÈë
  20          #define A_IN_normal  P1M1 &= ~0x02;   P1M0 &= ~0x02; //P16 //P2M1 &= ~0x80;   P2M0 &= ~0x80;  //P27  //0 0
             - ×¼Ë«Ïò¿Ú
  21          #define B_IN_normal  P1M1 &= ~0x04;   P1M0 &= ~0x04; //P16 //P2M1 &= ~0x80;   P2M0 &= ~0x80;  //P27  //0 0
             - ×¼Ë«Ïò¿Ú
  22          
  23          void stop_scroll(void)
  24          {
  25   1      //B_IN_hight_input ;  A_IN_hight_input ;
  26   1      PLUS_0_B_IN = PLUS_0_A_IN = 0;
  27   1      }
  28          void init_scroll()
  29          {
  30   1      A_IN_normal ;B_IN_normal;  PLUS_0_B_IN =PLUS_0_A_IN = 1;
  31   1          g_plus_a_in[0] = high;
  32   1          g_plus_b_in[0] = high;
  33   1          g_plus_a_in_old[0] =high;
  34   1          g_plus_b_in_old[0] = high;
  35   1          g_plus_status  [0] = e_stop;
  36   1              g_juggle_delay = 0;
  37   1              g_plus_count[0] = 0;
  38   1      }
  39          void scan_roll(char roll_index)
  40          {
  41   1          if(g_juggle_delay == 0)
  42   1          {   
  43   2              if(e_roll_a == roll_index)
  44   2              {
  45   3                  g_plus_a_in[e_roll_a] = PLUS_0_A_IN;
  46   3                  g_plus_b_in[e_roll_a] = PLUS_0_B_IN;
  47   3              }
  48   2      
  49   2              if( g_plus_a_in_old[roll_index] != g_plus_a_in[roll_index] || g_plus_b_in_old[roll_index] != g_plu
             -s_b_in[roll_index])
  50   2              {
C51 COMPILER V9.01   SCROLL                                                                01/14/2019 21:22:32 PAGE 2   

  51   3                  g_juggle_delay = 2;// filter juggle
  52   3              }
  53   2                      return;
  54   2          }
  55   1          else if(g_juggle_delay>1)
  56   1          {
  57   2              g_juggle_delay -- ;
  58   2              return;
  59   2          }
  60   1          g_juggle_delay = 0;
  61   1          if(e_roll_a == roll_index)
  62   1          {
  63   2              g_plus_a_in[e_roll_a] = PLUS_0_A_IN;
  64   2              g_plus_b_in[e_roll_a] = PLUS_0_B_IN;
  65   2          }
  66   1      
  67   1          if(high == g_plus_b_in[roll_index] && high == g_plus_a_in[roll_index])
  68   1          {
  69   2              g_plus_status[roll_index] = e_stop;
  70   2          } 
  71   1          switch(g_plus_status[roll_index])
  72   1          {
  73   2              case e_stop:
  74   2                  if(low == g_plus_a_in[roll_index] && high == g_plus_a_in_old[roll_index] && high == g_plus_b_i
             -n[roll_index])
  75   2                  {
  76   3                      g_plus_status[roll_index] = e_clockwise;
  77   3                  }       
  78   2                  else if(low == g_plus_b_in[roll_index] && high == g_plus_b_in_old[roll_index] && high == g_plu
             -s_a_in[roll_index])
  79   2                  {
  80   3                      g_plus_status[roll_index] = e_anti_clockwise;
  81   3                  }
  82   2              
  83   2              break;
  84   2              case e_clockwise:
  85   2                  if(high == g_plus_a_in[roll_index] && low == g_plus_a_in_old[roll_index] && low == g_plus_b_in
             -[roll_index])
  86   2                  {
  87   3                      g_plus_count[roll_index]++;
  88   3                      g_plus_status[roll_index] = e_wait_stop; 
  89   3                  }       
  90   2              break;
  91   2              case e_anti_clockwise:
  92   2                  if(high == g_plus_b_in[roll_index] && low == g_plus_b_in_old[roll_index] && low == g_plus_a_in
             -[roll_index])
  93   2                  {
  94   3                      g_plus_count[roll_index]--;
  95   3                      g_plus_status[roll_index] = e_wait_stop; 
  96   3                  } 
  97   2              break;
  98   2              case e_wait_stop:
  99   2                  if(high == g_plus_b_in[roll_index] && high == g_plus_a_in[roll_index])
 100   2                  {
 101   3                      g_plus_status[roll_index] = e_stop;
 102   3                  }
 103   2              break;
 104   2          }
 105   1          g_plus_a_in_old[roll_index] = g_plus_a_in[roll_index];
 106   1          g_plus_b_in_old[roll_index] = g_plus_b_in[roll_index];
 107   1      }
 108          #else
C51 COMPILER V9.01   SCROLL                                                                01/14/2019 21:22:32 PAGE 3   

              void init_scroll()
              {
                   g_plus_a_in[0] = low;
                      g_plus_b_in[0] = low;
                              g_plus_a_in_old[0] =low;
                  g_plus_b_in_old[0] = low;
                      g_plus_status  [0] = e_stop;
              }
              void scan_roll(char roll_index)
              {
                   if(e_roll_a == roll_index)
                  {
                      g_plus_a_in[e_roll_a] = PLUS_0_A_IN;
                      g_plus_b_in[e_roll_a] = PLUS_0_B_IN;
                  }
                  if( g_plus_a_in_old[roll_index] != g_plus_a_in[roll_index] && g_plus_b_in_old[roll_index] != g_plus_b_
             -in[roll_index])
                  {
                      _nop_();
                      if(e_roll_a == roll_index)
                      {
                          g_plus_a_in[e_roll_a] = PLUS_0_A_IN;
                          g_plus_b_in[e_roll_a] = PLUS_0_B_IN;
                      }
               
                
                  }
                  switch(g_plus_status[roll_index])
                  {
                      case e_stop:
                          if(high == g_plus_a_in[roll_index] && low == g_plus_a_in_old[roll_index])
                          {
                              if(low == g_plus_b_in[roll_index])
                              {
                                  g_plus_status[roll_index] = e_clockwise;
                                   
                                  g_plus_sub_status[roll_index] = e_pre_count;
                              }
                              else
                              {
                                  g_plus_status[roll_index] = e_anti_clockwise;
                                  
                                  g_plus_sub_status[roll_index] = e_pre_count;
                              }
                          }
                                      #if 1
                                      else if(high == g_plus_b_in[roll_index] && high == g_plus_a_in[roll_index])
                                      {
                              g_plus_status[roll_index] = e_anti_clockwise;
                              g_plus_sub_status[roll_index] = e_pre_count;
                          }
                                      #endif
                      break;
                      case e_clockwise:
                          switch(g_plus_sub_status[roll_index])
                          {
                              case e_pre_count:
                              if(high == g_plus_a_in[roll_index] && high == g_plus_b_in[roll_index] )
                              {
                                  g_plus_count[roll_index]++;     
                                  g_plus_sub_status[roll_index] = e_count;  
                              }
C51 COMPILER V9.01   SCROLL                                                                01/14/2019 21:22:32 PAGE 4   

                              else if(high == g_plus_a_in[roll_index] && low == g_plus_b_in[roll_index] )
                              {                                                          //wait...
                              }
                              else
                                  g_plus_status[roll_index] = e_stop;        
                              break;
                              
                              case e_count:
                                      //      send_buffer("{");send_integ(g_plus_a_in[roll_index]); send_integ(g_plus_b_in[roll_index]); send_buff
             -er("}");
                              //if(low == g_plus_a_in[roll_index] && low == g_plus_b_in[roll_index] )
                              {
                                                  
                                  g_plus_status[roll_index] = e_stop; 
                              }
                               
                               
                              break;
                            }
                          break;
                      case e_anti_clockwise:
                          switch(g_plus_sub_status[roll_index])
                          {
                             
                              case e_pre_count:
                                  if(high == g_plus_a_in[roll_index] && low == g_plus_b_in[roll_index] )
                                  {
                                      g_plus_count[roll_index] -- ;
                                      g_plus_sub_status[roll_index] = e_count;  
                                  }
                                  else if(high == g_plus_a_in[roll_index] && high == g_plus_b_in[roll_index] )
                                  {
                                                          //wait...
                                  }
                                  else
                                  {
                                      g_plus_status[roll_index] = e_stop;     
                                  }                    
                                  break;
                                  
                              case e_count:
                                               //   send_buffer("{");send_integ(g_plus_a_in[roll_index]); send_integ(g_plus_b_in[roll_index]); send_
             -buffer("}");
                                  if(low == g_plus_a_in[roll_index] && low == g_plus_b_in[roll_index] )
                                  {
                                       g_plus_status[roll_index] = e_stop; 
                                  }
                                                  
                                  break;
                          }
                          break;
                      default:
                      break;
                  }    
                  g_plus_a_in_old[roll_index] = g_plus_a_in[roll_index];
                  g_plus_b_in_old[roll_index] = g_plus_b_in[roll_index];
              
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.01   SCROLL                                                                01/14/2019 21:22:32 PAGE 5   

   CODE SIZE        =    359    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =      8    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
