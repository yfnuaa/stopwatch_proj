C51 COMPILER V9.01   SCROLL                                                                12/20/2018 20:23:41 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE SCROLL
OBJECT MODULE PLACED IN scroll.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE src\scroll.c COMPACT BROWSE PRINT(.\scroll.lst) OBJECT(scroll.obj)

line level    source

   1          #include "../h/port.h"
   2          #include "../h/scroll.h"
   3          #include "../h/utility.h"
   4          #include "../h/serial.h"
   5          
   6          sbit PLUS_0_A_IN = P1^1;
   7          sbit PLUS_0_B_IN = P1^2;
   8          char g_plus_status  [e_roll_max] = {e_stop};
   9          char g_plus_sub_status  [e_roll_max] = {e_stop};
  10          
  11          char g_plus_a_in    [e_roll_max] = {high};
  12          char g_plus_a_in_old[e_roll_max] = {high};
  13          char g_plus_b_in    [e_roll_max] = {high};
  14          char g_plus_b_in_old[e_roll_max] = {high};
  15          char g_plus_count[ e_roll_max] = {0};    
  16          #if 1                                                                            
  17          uchar g_juggle_delay = 0;
  18          void init_scroll()
  19          {
  20   1          g_plus_a_in[0] = high;
  21   1          g_plus_b_in[0] = high;
  22   1          g_plus_a_in_old[0] =high;
  23   1          g_plus_b_in_old[0] = high;
  24   1          g_plus_status  [0] = e_stop;
  25   1              g_juggle_delay = 0;
  26   1              g_plus_count[0] = 0;
  27   1      }
  28          void scan_roll(char roll_index)
  29          {
  30   1          if(g_juggle_delay == 0)
  31   1          {   
  32   2              if(e_roll_a == roll_index)
  33   2              {
  34   3                  g_plus_a_in[e_roll_a] = PLUS_0_A_IN;
  35   3                  g_plus_b_in[e_roll_a] = PLUS_0_B_IN;
  36   3              }
  37   2      
  38   2              if( g_plus_a_in_old[roll_index] != g_plus_a_in[roll_index] || g_plus_b_in_old[roll_index] != g_plu
             -s_b_in[roll_index])
  39   2              {
  40   3                  g_juggle_delay = 2;// filter juggle
  41   3              }
  42   2                      return;
  43   2          }
  44   1          else if(g_juggle_delay>1)
  45   1          {
  46   2              g_juggle_delay -- ;
  47   2              return;
  48   2          }
  49   1          g_juggle_delay = 0;
  50   1          if(e_roll_a == roll_index)
  51   1          {
  52   2              g_plus_a_in[e_roll_a] = PLUS_0_A_IN;
  53   2              g_plus_b_in[e_roll_a] = PLUS_0_B_IN;
  54   2          }
C51 COMPILER V9.01   SCROLL                                                                12/20/2018 20:23:41 PAGE 2   

  55   1      
  56   1          if(high == g_plus_b_in[roll_index] && high == g_plus_a_in[roll_index])
  57   1          {
  58   2              g_plus_status[roll_index] = e_stop;
  59   2          } 
  60   1          switch(g_plus_status[roll_index])
  61   1          {
  62   2              case e_stop:
  63   2                  if(low == g_plus_a_in[roll_index] && high == g_plus_a_in_old[roll_index] && high == g_plus_b_i
             -n[roll_index])
  64   2                  {
  65   3                      g_plus_status[roll_index] = e_clockwise;
  66   3                  }       
  67   2                  else if(low == g_plus_b_in[roll_index] && high == g_plus_b_in_old[roll_index] && high == g_plu
             -s_a_in[roll_index])
  68   2                  {
  69   3                      g_plus_status[roll_index] = e_anti_clockwise;
  70   3                  }
  71   2              
  72   2              break;
  73   2              case e_clockwise:
  74   2                  if(high == g_plus_a_in[roll_index] && low == g_plus_a_in_old[roll_index] && low == g_plus_b_in
             -[roll_index])
  75   2                  {
  76   3                      g_plus_count[roll_index]++;
  77   3                      g_plus_status[roll_index] = e_wait_stop; 
  78   3                  }       
  79   2              break;
  80   2              case e_anti_clockwise:
  81   2                  if(high == g_plus_b_in[roll_index] && low == g_plus_b_in_old[roll_index] && low == g_plus_a_in
             -[roll_index])
  82   2                  {
  83   3                      g_plus_count[roll_index]--;
  84   3                      g_plus_status[roll_index] = e_wait_stop; 
  85   3                  } 
  86   2              break;
  87   2              case e_wait_stop:
  88   2                  if(high == g_plus_b_in[roll_index] && high == g_plus_a_in[roll_index])
  89   2                  {
  90   3                      g_plus_status[roll_index] = e_stop;
  91   3                  }
  92   2              break;
  93   2          }
  94   1          g_plus_a_in_old[roll_index] = g_plus_a_in[roll_index];
  95   1          g_plus_b_in_old[roll_index] = g_plus_b_in[roll_index];
  96   1      }
  97          #else
              void init_scroll()
              {
                   g_plus_a_in[0] = low;
                      g_plus_b_in[0] = low;
                              g_plus_a_in_old[0] =low;
                  g_plus_b_in_old[0] = low;
                      g_plus_status  [0] = e_stop;
              }
              void scan_roll(char roll_index)
              {
                   if(e_roll_a == roll_index)
                  {
                      g_plus_a_in[e_roll_a] = PLUS_0_A_IN;
                      g_plus_b_in[e_roll_a] = PLUS_0_B_IN;
                  }
C51 COMPILER V9.01   SCROLL                                                                12/20/2018 20:23:41 PAGE 3   

                  if( g_plus_a_in_old[roll_index] != g_plus_a_in[roll_index] && g_plus_b_in_old[roll_index] != g_plus_b_
             -in[roll_index])
                  {
                      _nop_();
                      if(e_roll_a == roll_index)
                      {
                          g_plus_a_in[e_roll_a] = PLUS_0_A_IN;
                          g_plus_b_in[e_roll_a] = PLUS_0_B_IN;
                      }
               
                
                  }
                  switch(g_plus_status[roll_index])
                  {
                      case e_stop:
                          if(high == g_plus_a_in[roll_index] && low == g_plus_a_in_old[roll_index])
                          {
                              if(low == g_plus_b_in[roll_index])
                              {
                                  g_plus_status[roll_index] = e_clockwise;
                                   
                                  g_plus_sub_status[roll_index] = e_pre_count;
                              }
                              else
                              {
                                  g_plus_status[roll_index] = e_anti_clockwise;
                                  
                                  g_plus_sub_status[roll_index] = e_pre_count;
                              }
                          }
                                      #if 1
                                      else if(high == g_plus_b_in[roll_index] && high == g_plus_a_in[roll_index])
                                      {
                              g_plus_status[roll_index] = e_anti_clockwise;
                              g_plus_sub_status[roll_index] = e_pre_count;
                          }
                                      #endif
                      break;
                      case e_clockwise:
                          switch(g_plus_sub_status[roll_index])
                          {
                              case e_pre_count:
                              if(high == g_plus_a_in[roll_index] && high == g_plus_b_in[roll_index] )
                              {
                                  g_plus_count[roll_index]++;     
                                  g_plus_sub_status[roll_index] = e_count;  
                              }
                              else if(high == g_plus_a_in[roll_index] && low == g_plus_b_in[roll_index] )
                              {                                                          //wait...
                              }
                              else
                                  g_plus_status[roll_index] = e_stop;        
                              break;
                              
                              case e_count:
                                      //      send_buffer("{");send_integ(g_plus_a_in[roll_index]); send_integ(g_plus_b_in[roll_index]); send_buff
             -er("}");
                              //if(low == g_plus_a_in[roll_index] && low == g_plus_b_in[roll_index] )
                              {
                                                  
                                  g_plus_status[roll_index] = e_stop; 
                              }
C51 COMPILER V9.01   SCROLL                                                                12/20/2018 20:23:41 PAGE 4   

                               
                               
                              break;
                            }
                          break;
                      case e_anti_clockwise:
                          switch(g_plus_sub_status[roll_index])
                          {
                             
                              case e_pre_count:
                                  if(high == g_plus_a_in[roll_index] && low == g_plus_b_in[roll_index] )
                                  {
                                      g_plus_count[roll_index] -- ;
                                      g_plus_sub_status[roll_index] = e_count;  
                                  }
                                  else if(high == g_plus_a_in[roll_index] && high == g_plus_b_in[roll_index] )
                                  {
                                                          //wait...
                                  }
                                  else
                                  {
                                      g_plus_status[roll_index] = e_stop;     
                                  }                    
                                  break;
                                  
                              case e_count:
                                               //   send_buffer("{");send_integ(g_plus_a_in[roll_index]); send_integ(g_plus_b_in[roll_index]); send_
             -buffer("}");
                                  if(low == g_plus_a_in[roll_index] && low == g_plus_b_in[roll_index] )
                                  {
                                       g_plus_status[roll_index] = e_stop; 
                                  }
                                                  
                                  break;
                          }
                          break;
                      default:
                      break;
                  }    
                  g_plus_a_in_old[roll_index] = g_plus_a_in[roll_index];
                  g_plus_b_in_old[roll_index] = g_plus_b_in[roll_index];
              
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    338    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =      8    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
