C51 COMPILER V9.01   ALARM                                                                 01/14/2019 21:45:55 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE ALARM
OBJECT MODULE PLACED IN alarm.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE src\alarm.c COMPACT BROWSE PRINT(.\alarm.lst) OBJECT(alarm.obj)

line level    source

   1          #include "../h/port.h"
   2          #include "../h/alarm.h"    
   3          #include "../h/serial.h"
   4          #include "../h/systimer.h"
   5          uchar volatile g_HZ_H_duty_h = 0;
   6          uchar volatile g_HZ_L_duty_h = 0;
   7          uchar volatile g_HZ_H_duty_l = 0;
   8          uchar volatile g_HZ_L_duty_l = 0; 
   9          sbit g_buzzer = P3^2;
  10          char g_duty = 50;
  11          #define ON 1
  12          #define OFF 0
  13          void Time1(void) interrupt 12  //“interrupt”声明函数为中断服务函数
  14          //其后的1 为定时器T0 的中断编号；0 表示使用第0 组工作
  15          {       
  16   1          AUXINTIF &= ~T2IF;                          //清中断标志
  17   1          g_buzzer = ~g_buzzer;
  18   1          if(ON == g_buzzer)
  19   1          {
  20   2              T2H = g_HZ_H_duty_h;
  21   2              T2L = g_HZ_L_duty_h; 
  22   2          }
  23   1          else
  24   1          {
  25   2              T2H = g_HZ_H_duty_l;
  26   2              T2L = g_HZ_L_duty_l; 
  27   2          }
  28   1          //T2H= g_HZ_H;         //(65536-56083)/256; //定时器T2 的高8 位重新赋初值
  29   1          //T2L= g_HZ_L;         //(65536-56083)%256; //定时器T0 的高8 位重新赋初值
  30   1      }
  31          void init_timer2(void)
  32          {
  33   1          T2L = g_HZ_L_duty_l;   //65536-11.0592M/12/1000
  34   1          T2H = g_HZ_H_duty_l;   
  35   1          // AUXR &= 0xFB;       //1/12 T
  36   1          AUXR |= 0x04;           //Timer clock is 1T mode
  37   1          AUXR |= 0x10;          //启动定时器
  38   1          IE2  |= ET2;           //使能定时器中断
  39   1          EA    = 1;             
  40   1      }     
  41          #if 0 
              void PWM_Isr() interrupt 22 using 1
              {
                  if (PWMCFG & 0x80)
                  {
                      PWMCFG &= ~0x80;                        //清中断标志
                      P14    = !P14;                             //测试端口
                  }
              }
              void init_pwm()
              {
                  P_SW2   = 0x80;
                  PWMCKS  = 0x0f;                              // PWM时钟为系统时钟/16
                  PWMC    = 0x0100;                              //设置PWM周期为256个PWM时钟
                  P_SW2   = 0x00;
C51 COMPILER V9.01   ALARM                                                                 01/14/2019 21:45:55 PAGE 2   

                  PWMFDCR = 0x7a;                             //能IO口异常检测中断
                  PWMCR   = 0xc0;                               //启动PWM模块并使能PWM计数器中断
                  EA      = 1;
              }
              #endif
  61          void set_duty(char duty)
  62          {
  63   1         g_duty = duty; 
  64   1      }
  65          #ifdef SYS_HZ_4M
  66          #define SYS_HZ 4000000
  67          #elif define SYS_HZ_6M
              #define SYS_HZ 6000000
              #elif define SYS_HZ_27M
              #define SYS_HZ 27000000
              #endif
  72          //#define SYS_HZ_6M
  73          //#define SYS_HZ_27M
  74          #if 0
              void set_HZ(float HZ)
              {
                  unsigned int temp;
                  unsigned int duty;
                  temp = 65536 - SYS_HZ/2/HZ;       //2000000/(HZ>>1);
                     
                  g_HZ_L_duty_l = g_HZ_L_duty_h = temp&0xFF;
                  g_HZ_H_duty_l = g_HZ_H_duty_h = temp>>8;     
              }
              #else
  85          void set_HZ(float HZ)
  86          {
  87   1          u32 temp = 0;
  88   1          u32  duty = 0;
  89   1          temp = SYS_HZ/HZ;
  90   1      
  91   1          duty = temp*g_duty/100;        //duty high part
  92   1          duty = 65536 - duty; 
  93   1          
  94   1          g_HZ_L_duty_h = duty&0xFF;
  95   1          g_HZ_H_duty_h = duty>>8;     
  96   1      
  97   1          duty = temp - duty;            // duty low part
  98   1          duty = 65536 - duty; 
  99   1          
 100   1          g_HZ_L_duty_l = duty&0xFF;
 101   1          g_HZ_H_duty_l = duty>>8;    
 102   1      }
 103          #endif
 104          #define buzzer_pin_normal  P3M1 &= ~0x04;   P3M0 &= ~0x04; //P16 //P2M1 &= ~0x80;   P2M0 &= ~0x80;  //P27 
             - //0 0 准双向口
 105          #define buzzer_pin_high_output  P3M1 &= ~0x04; P3M0 |= 0x04; //P16  //P2M1 &= ~0x80; P2M0 |= 0x80; //P27  
             - //0 1 推挽输出
 106          
 107          void start_alarm()
 108          {       
 109   1         // buzzer_pin_high_output;
 110   1          init_timer2();
 111   1      }
 112          
 113          void stop_alarm()
 114          {
 115   1          AUXR &= 0xEF;                    //停止定时器
C51 COMPILER V9.01   ALARM                                                                 01/14/2019 21:45:55 PAGE 3   

 116   1          //IE2 = IE2&(~ET2);
 117   1      //      buzzer_pin_normal;
 118   1          g_buzzer = OFF;
 119   1      }
 120          
 121          //----------------------------blink LED ----------------------------------
 122          #define ON  1
 123          #define OFF 0
 124          sbit g_led_R_port = P0^3;
 125          sbit g_led_G_port = P0^2;
 126          sbit g_led_B_port = P0^1;
 127          u8   g_ledR_counter, g_ledG_counter, g_ledB_counter;
 128          u8   g_ledR_duty, g_ledG_duty, g_ledB_duty;
 129          
 130          void update_breath_blink()
 131          {
 132   1          if(g_led_R_port != ON && g_ledR_counter <= g_ledR_duty)
 133   1          {
 134   2              g_led_R_port = ON;
 135   2          }
 136   1          else if(g_led_R_port == ON && g_ledR_counter> g_ledR_duty)
 137   1          {
 138   2              g_led_R_port = OFF;
 139   2          }
 140   1      
 141   1      
 142   1          if(g_led_G_port != ON && g_ledG_counter <= g_ledG_duty)
 143   1          {
 144   2              g_led_G_port = ON;
 145   2          }
 146   1          else if(g_led_G_port != OFF && g_ledG_counter > g_ledG_duty)
 147   1          {
 148   2              g_led_G_port = OFF;
 149   2          }
 150   1      
 151   1      
 152   1          if(g_led_B_port != ON  && g_ledB_counter <= g_ledB_duty)
 153   1          {
 154   2              g_led_B_port = ON;
 155   2          }
 156   1          else if(g_led_B_port != OFF && g_ledB_counter > g_ledB_duty)
 157   1          {
 158   2              g_led_B_port = OFF;
 159   2          }
 160   1      }
 161          bit g_breath_led_on = 0;
 162          char g_breath_led_r_direction, g_breath_led_g_direction, g_breath_led_b_direction;
 163          void close_rgb_led()
 164          {
 165   1          g_led_R_port = g_led_G_port = g_led_B_port = OFF;
 166   1          g_breath_led_on = 0;     IE2 &= ~ET4;  // stop blink 
 167   1      
 168   1      }
 169          void poll_led_breath_1700us()
 170          {
 171   1          g_ledR_counter++;
 172   1          g_ledG_counter++;
 173   1          g_ledB_counter++;
 174   1          
 175   1          if(g_ledR_counter == 11)g_ledR_counter = 1;
 176   1          if(g_ledG_counter == 11)g_ledG_counter = 1;
 177   1          if(g_ledB_counter == 11)g_ledB_counter = 1;
C51 COMPILER V9.01   ALARM                                                                 01/14/2019 21:45:55 PAGE 4   

 178   1              
 179   1          update_breath_blink();
 180   1          {
 181   2              static long duty_counter = 0;
 182   2              duty_counter++;
 183   2              //if(duty_counter == 400)//every 1/10 s duty ++ or duty --  ,accomplish breath light    at 10us  1
             -000hz
 184   2              //if(duty_counter == 20000)//every 1/10 s duty ++ or duty --  ,accomplish breath light   at20us  5
             -00HZ
 185   2              if(duty_counter == 120/*1.7ms * 150 = 250ms*/)//every 1/5 s duty ++ or duty --  ,accomplish breath
             - light   at40us  250HZ
 186   2              {
 187   3                  duty_counter = 0;
 188   3                  
 189   3                  if(g_ledR_duty >= 30) { g_breath_led_r_direction=-3; }
 190   3                  else if (g_ledR_duty < 2) { g_breath_led_r_direction=3; }
 191   3                  g_ledR_duty += g_breath_led_r_direction;
 192   3                  
 193   3                  if(g_ledG_duty >= 30) { g_breath_led_g_direction=-3; }
 194   3                  else if (g_ledG_duty < 2) { g_breath_led_g_direction=3; }
 195   3                  g_ledG_duty += g_breath_led_g_direction;
 196   3                  
 197   3                  if(g_ledB_duty >= 30) { g_breath_led_b_direction=-3; }
 198   3                  else if (g_ledB_duty < 2) { g_breath_led_b_direction=3; }
 199   3                  g_ledB_duty += g_breath_led_b_direction; 
 200   3              }
 201   2          }
 202   1      }
 203          
 204          void poll_led_alarm_100ms()
 205          {
 206   1          g_ledR_counter++;
 207   1          g_ledG_counter++;
 208   1          g_ledB_counter++;
 209   1          if(g_ledR_counter == 101)g_ledR_counter = 1;
 210   1          if(g_ledG_counter == 101)g_ledG_counter = 1;
 211   1          if(g_ledB_counter == 101)g_ledB_counter = 1;
 212   1          g_led_R_port = g_led_G_port = g_led_B_port = OFF;
 213   1          if(g_ledR_counter == 1) g_led_R_port = ON;
 214   1          if(g_ledG_counter == 1) g_led_G_port = ON;
 215   1          if(g_ledB_counter == 1) g_led_B_port = ON;
 216   1      }
 217          
 218          #if 1
 219          void TM4_Isr() interrupt 20 using 1
 220          {
 221   1          AUXINTIF &= ~T4IF;           //clear interrupt flag
 222   1          if(g_breath_led_on)
 223   1          {
 224   2              poll_led_breath_1700us();
 225   2          }
 226   1          else   // alarm led
 227   1          {
 228   2              poll_led_alarm_100ms();    
 229   2          }
 230   1      }
 231           
 232          void Timer4Init_breath_1700us(void)    //1ms@4MHz
 233          {
 234   1          T4T3M |= 0x20;       //Timer clock is 1T mode    
 235   1              //T4T3M &= 0xDF;                //Timer clock is 12T mode
 236   1          T4L = 0x70 ;         //Initial timer value     //1000HZ
C51 COMPILER V9.01   ALARM                                                                 01/14/2019 21:45:55 PAGE 5   

 237   1          T4H = 0xE5;            //Initial timer value
 238   1          T4T3M |= 0x80;         //Timer4 start run
 239   1          IE2 |= ET4;
 240   1          EA = 1;
 241   1      }
 242          void Timer4Init_alarm_100ms(void)    //1ms@4MHz
 243          {
 244   1              T4T3M &= 0xDF;          //Timer clock is 12T mode
 245   1          T4L = 0xCB;         //Initial timer value     //1000HZ
 246   1          T4H = 0x7D;            //Initial timer value
 247   1          T4T3M |= 0x80;         //Timer4 start run
 248   1          IE2 |= ET4;
 249   1          EA = 1;
 250   1      }
 251          #endif 
 252          
 253          void start_breath_blink()
 254          {
 255   1          g_ledR_duty = 50;//g_sys_1ms_ticket%100;
 256   1          g_ledG_duty = 25;//(g_sys_1ms_ticket>>1)%100;
 257   1          g_ledB_duty = 0;//(g_ledR_duty+10)%100;
 258   1          g_ledR_counter  = 0;// g_sys_1ms_ticket%100;
 259   1          g_ledG_counter  = 0;//(g_sys_1ms_ticket>>1)%100;
 260   1          g_ledB_counter  = 0;//(g_ledR_duty+10)%100;
 261   1          g_breath_led_on = 1;
 262   1          g_breath_led_r_direction = 3;
 263   1          g_breath_led_g_direction = 3;
 264   1          g_breath_led_b_direction = 3;
 265   1      //  g_led_timer_HL = 0xFFD8;  //10us  //0xFFD8  Tled= 1ms  1000 HZ
 266   1      //  g_led_timer_HL = 0xFFB0;  //20us  //0xFFB0  Tled= 2ms  500  HZ
 267   1      //    g_led_timer_HL = 0xE570;// 0xE570;  //1.7ms  // Tled= 17ms  at 60HZ
 268   1          Timer4Init_breath_1700us();
 269   1      }
 270          void start_alarm_blink()
 271          {
 272   1          g_ledR_counter = g_sys_10ms_ticket%10;
 273   1          g_ledG_counter = (g_sys_10ms_ticket>>1)%10;
 274   1          g_ledB_counter = (g_ledR_counter+3)%10;
 275   1          g_breath_led_on = 0;
 276   1          Timer4Init_alarm_100ms();
 277   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    935    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     18      12
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
