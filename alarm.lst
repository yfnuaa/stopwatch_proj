C51 COMPILER V9.01   ALARM                                                                 12/20/2018 20:32:00 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE ALARM
OBJECT MODULE PLACED IN alarm.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE src\alarm.c COMPACT BROWSE PRINT(.\alarm.lst) OBJECT(alarm.obj)

line level    source

   1          #include "../h/port.h"
   2          #include "../h/alarm.h"    
   3          #include "../h/serial.h"
   4          #include "../h/systimer.h"
   5          uchar volatile g_HZ_H_duty_h = 0;
   6          uchar volatile g_HZ_L_duty_h = 0;
   7          uchar volatile g_HZ_H_duty_l = 0;
   8          uchar volatile g_HZ_L_duty_l = 0; 
   9          sbit g_buzzer = P3^2;
  10          char g_duty = 50;
  11          void Time1(void) interrupt 12  //“interrupt”声明函数为中断服务函数
  12          //其后的1 为定时器T0 的中断编号；0 表示使用第0 组工作
  13          {       
  14   1          AUXINTIF &= ~T2IF;                          //清中断标志
  15   1          g_buzzer = ~g_buzzer;
  16   1          if(!g_buzzer)
  17   1          {
  18   2              T2H = g_HZ_H_duty_h;
  19   2              T2L = g_HZ_L_duty_h; 
  20   2          }
  21   1          else
  22   1          {
  23   2              T2H = g_HZ_H_duty_l;
  24   2              T2L = g_HZ_L_duty_l; 
  25   2          }
  26   1          //T2H= g_HZ_H;         //(65536-56083)/256; //定时器T2 的高8 位重新赋初值
  27   1          //T2L= g_HZ_L;         //(65536-56083)%256; //定时器T0 的高8 位重新赋初值
  28   1      }
  29          void init_timer2(void)
  30          {
  31   1          T2L = g_HZ_L_duty_h;   //65536-11.0592M/12/1000
  32   1          T2H = g_HZ_H_duty_h;   
  33   1          // AUXR &= 0xFB;       //1/12 T
  34   1          AUXR |= 0x04;           //Timer clock is 1T mode
  35   1          AUXR |= 0x10;          //启动定时器
  36   1          IE2  |= ET2;           //使能定时器中断
  37   1          EA    = 1;             
  38   1       
  39   1      }     
  40          #if 0 
              void PWM_Isr() interrupt 22 using 1
              {
                  if (PWMCFG & 0x80)
                  {
                      PWMCFG &= ~0x80;                        //清中断标志
                      P14    = !P14;                             //测试端口
                  }
              }
              void init_pwm()
              {
                  P_SW2   = 0x80;
                  PWMCKS  = 0x0f;                              // PWM时钟为系统时钟/16
                  PWMC    = 0x0100;                              //设置PWM周期为256个PWM时钟
                  P_SW2   = 0x00;
                  PWMFDCR = 0x7a;                             //能IO口异常检测中断
C51 COMPILER V9.01   ALARM                                                                 12/20/2018 20:32:00 PAGE 2   

                  PWMCR   = 0xc0;                               //启动PWM模块并使能PWM计数器中断
                  EA      = 1;
              }
              #endif
  60          void set_duty(char duty)
  61          {
  62   1          if(duty<100 && duty>0) g_duty = duty; 
  63   1      }
  64          #ifdef SYS_HZ_4M
  65          #define SYS_HZ 4000000
  66          #elif define SYS_HZ_6M
              #define SYS_HZ 6000000
              #elif define SYS_HZ_27M
              #define SYS_HZ 27000000
              #endif
  71          //#define SYS_HZ_6M
  72          //#define SYS_HZ_27M
  73          void set_HZxx(float HZ)
  74          {
  75   1          unsigned int temp;
  76   1          unsigned int duty;
  77   1          temp = 65536 - SYS_HZ/HZ;       //2000000/(HZ>>1);
  78   1             
  79   1          g_HZ_L_duty_l = g_HZ_L_duty_h = temp&0xFF;
  80   1          g_HZ_H_duty_l = g_HZ_H_duty_h = temp>>8;     
  81   1      }
*** WARNING C280 IN LINE 76 OF SRC\ALARM.C: 'duty': unreferenced local variable
  82          void set_HZ(float HZ)
  83          {
  84   1          u32 temp = 0;
  85   1          u8  duty = 0;
  86   1          temp = SYS_HZ/HZ;
  87   1      
  88   1          duty = temp*g_duty/100;        //duty high part
  89   1          duty = 65536 - duty; 
  90   1          
  91   1          g_HZ_L_duty_h = duty&0xFF;
  92   1          g_HZ_H_duty_h = duty>>8;     
  93   1      
  94   1          duty = temp - duty;            // duty low part
  95   1          duty = 65536 - duty; 
  96   1          
  97   1          g_HZ_L_duty_l = duty&0xFF;
  98   1          g_HZ_H_duty_l = duty>>8;    
  99   1      }
 100          void start_alarm()
 101          {
 102   1          init_timer2();
 103   1      }
 104          void stop_alarm()
 105          {
 106   1          AUXR &= 0xEF;                    //停止定时器
 107   1          //IE2 = IE2&(~ET2);
 108   1          g_buzzer = 1;
 109   1      }
 110          
 111          //----------------------------blink LED ----------------------------------
 112          #define ON  0
 113          #define OFF 1
 114          sbit g_led_R_port = P0^1;
 115          sbit g_led_G_port = P0^2;
 116          sbit g_led_B_port = P0^3;
C51 COMPILER V9.01   ALARM                                                                 12/20/2018 20:32:00 PAGE 3   

 117          u8   g_ledR_counter, g_ledG_counter, g_ledB_counter;
 118          u8   g_ledR_duty, g_ledG_duty, g_ledB_duty;
 119          
 120          void update_breath_blink()
 121          {
 122   1          if(g_led_R_port != ON && g_ledR_counter <= g_ledR_duty)
 123   1          {
 124   2              g_led_R_port = ON;
 125   2          }
 126   1          else if(g_led_R_port == ON && g_ledR_counter> g_ledR_duty)
 127   1          {
 128   2              g_led_R_port = OFF;
 129   2          }
 130   1      
 131   1      
 132   1              if(g_led_G_port != ON && g_ledG_counter <= g_ledG_duty)
 133   1          {
 134   2              g_led_G_port = ON;
 135   2          }
 136   1          else if(g_led_G_port != OFF && g_ledG_counter > g_ledG_duty)
 137   1          {
 138   2              g_led_G_port = OFF;
 139   2          }
 140   1      
 141   1      
 142   1              if(g_led_B_port != ON  && g_ledB_counter <= g_ledB_duty)
 143   1          {
 144   2              g_led_B_port = ON;
 145   2          }
 146   1          else if(g_led_B_port != OFF && g_ledB_counter > g_ledB_duty)
 147   1          {
 148   2              g_led_B_port = OFF;
 149   2          }
 150   1      }
 151          bit g_breath_led_on = 0;
 152          void close_led()
 153          {
 154   1              IE2 &= ~ET4;  // stop blink 
 155   1          g_led_R_port = g_led_G_port = g_led_B_port = OFF;
 156   1              g_breath_led_on = 0;
 157   1      }
 158          void poll_led_breath_1ms()
 159          {
 160   1              g_ledR_counter++;
 161   1              g_ledG_counter++;
 162   1              g_ledB_counter++;
 163   1              if(g_ledR_counter == 101)g_ledR_counter = 1;
 164   1              if(g_ledG_counter == 101)g_ledG_counter = 1;
 165   1              if(g_ledB_counter == 101)g_ledB_counter = 1;
 166   1              update_breath_blink();
 167   1              {
 168   2                      static u16 duty_counter = 0;
 169   2                      duty_counter++;
 170   2                      if(0)//duty_counter == 200000)//every 1/10 s duty ++
 171   2                      {
 172   3                              duty_counter = 0;
 173   3                              g_ledR_duty++;if(g_ledR_duty>100)g_ledR_duty = 1;
 174   3                              g_ledG_duty++;if(g_ledG_duty>100)g_ledG_duty = 1;
 175   3                              g_ledB_duty++;if(g_ledB_duty>100)g_ledB_duty = 1;
 176   3                      }
 177   2              }
 178   1      }
C51 COMPILER V9.01   ALARM                                                                 12/20/2018 20:32:00 PAGE 4   

 179          
 180          void poll_led_alarm_100ms()
 181          {
 182   1              g_ledR_counter++;
 183   1              g_ledG_counter++;
 184   1              g_ledB_counter++;
 185   1              if(g_ledR_counter == 11)g_ledR_counter = 1;
 186   1              if(g_ledG_counter == 11)g_ledG_counter = 1;
 187   1              if(g_ledB_counter == 11)g_ledB_counter = 1;
 188   1              g_led_R_port = g_led_G_port = g_led_B_port = OFF;
 189   1          if(g_ledR_counter == 1) g_led_R_port = ON;
 190   1              if(g_ledG_counter == 1) g_led_G_port = ON;
 191   1              if(g_ledB_counter == 1) g_led_B_port = ON;
 192   1      }
 193          #if 1
 194          
 195          void TM4_Isr() interrupt 20 using 1
 196          {
 197   1              AUXINTIF &= ~T4IF;           //clear interrupt flag
 198   1              if(g_breath_led_on)
 199   1              {
 200   2                  poll_led_breath_1ms();
 201   2              }
 202   1          else   // alarm led
 203   1              {
 204   2                  poll_led_alarm_100ms();     
 205   2              }
 206   1      }
 207          u16 g_led_timer_HL = 0xFEB3;
 208          void Timer4Init(void)        //1ms@4MHz
 209          {
 210   1          T4T3M &= 0xDF;         //Timer clock is 12T mode    
 211   1      
 212   1          T4L = g_led_timer_HL&&0xFF;            //Initial timer value     //1000HZ
 213   1          T4H = g_led_timer_HL>>8;            //Initial timer value
 214   1      
 215   1          T4T3M |= 0x80;         //Timer4 start run
 216   1          IE2 |= ET4;
 217   1          EA = 1;
 218   1      }
 219          #endif 
 220          
 221          void start_breath_blink()
 222          {
 223   1              g_ledR_duty = 10;//g_sys_1ms_ticket%100;
 224   1              g_ledG_duty = 10;//(g_sys_1ms_ticket>>1)%100;
 225   1              g_ledB_duty = 10;//(g_ledR_duty+10)%100;
 226   1              g_ledR_counter = 0;// g_sys_1ms_ticket%100;
 227   1              g_ledG_counter = 0;//(g_sys_1ms_ticket>>1)%100;
 228   1              g_ledB_counter = 0;//(g_ledR_duty+10)%100;
 229   1              g_breath_led_on = 1;
 230   1              g_led_timer_HL = 0xFFEF; //1ms    0x7DBC  //100ms
 231   1              Timer4Init();
 232   1      }
 233          void start_alarm_blink()
 234          {
 235   1              g_ledR_counter = g_sys_1ms_ticket%10;
 236   1              g_ledG_counter = (g_sys_1ms_ticket>>1)%10;
 237   1              g_ledB_counter = (g_ledR_counter+10)%10;
 238   1              g_breath_led_on = 0;
 239   1              g_led_timer_HL = 0x7DBC; //0xFEB3  //1ms    0x7DBC  //100ms
 240   1              Timer4Init();
C51 COMPILER V9.01   ALARM                                                                 12/20/2018 20:32:00 PAGE 5   

 241   1      }
 242           
 243          
 244          
 245          
 246          
 247          
 248          
 249          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    666    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     15      10
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
